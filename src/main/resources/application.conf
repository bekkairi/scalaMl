###################################
# akka-http Reference Config File #
###################################

# This is the reference config file that contains all the default settings.
# Make your edits/overrides in your application.conf.

play.crypto.secret="secret"
play.crypto.secret=${?APPLICATION_SECRET}

akka.http {
  routing {
    # Enables/disables the returning of more detailed error messages to the
    # client in the error response
    # Should be disabled for browser-facing APIs due to the risk of XSS attacks
    # and (probably) enabled for internal or non-browser APIs
    # (Note that akka-http will always produce log messages containing the full error details)
    verbose-error-messages = off

    # Enables/disables ETag and `If-Modified-Since` support for FileAndResourceDirectives
    file-get-conditional = on

    # Enables/disables the rendering of the "rendered by" footer in directory listings
    render-vanity-footer = yes

    # The maximum size between two requested ranges. Ranges with less space in between will be coalesced.
    #
    # When multiple ranges are requested, a server may coalesce any of the ranges that overlap or that are separated
    # by a gap that is smaller than the overhead of sending multiple parts, regardless of the order in which the
    # corresponding byte-range-spec appeared in the received Range header field. Since the typical overhead between
    # parts of a multipart/byteranges payload is around 80 bytes, depending on the selected representation's
    # media type and the chosen boundary parameter length, it can be less efficient to transfer many small
    # disjoint parts than it is to transfer the entire selected representation.
    range-coalescing-threshold = 80

    # The maximum number of allowed ranges per request.
    # Requests with more ranges will be rejected due to DOS suspicion.
    range-count-limit = 16

    # The maximum number of bytes per ByteString a decoding directive will produce
    # for an entity data stream.
    decode-max-bytes-per-chunk = 1m

    # Maximum content length after applying a decoding directive. When the directive
    # decompresses, for example, an entity compressed with gzip, the resulting stream can be much
    # larger than the max-content-length. Like with max-content-length, this is not necessarilly a
    # problem when consuming the entity in a streaming fashion, but does risk high memory use
    # when the entity is made strict or marshalled into an in-memory object.
    # This limit (like max-content-length) can be overridden on a case-by-case basis using the
    # withSizeLimit directive.
    decode-max-size = 8m
  }

  # server-sent events
  sse {
    # The maximum size for parsing server-sent events.
    max-event-size = 8192

    # The maximum size for parsing lines of a server-sent event.
    max-line-size = 4096
  }
}

play {
  server {

    # The root directory for the Play server instance. This value can
    # be set by providing a path as the first argument to the Play server
    # launcher script. See `ServerConfig.loadConfiguration`.
    dir = ${?user.dir}

    # HTTP configuration
    http {
      # The HTTP port of the server. Use a value of "disabled" if the server
      # shouldn't bind an HTTP port.
      port = 9000
      port = ${?http.port}

      # The interface address to bind to.
      address = "0.0.0.0"
      address = ${?http.address}
    }

    # HTTPS configuration
    https {

      # The HTTPS port of the server.
      port = ${?https.port}

      # The interface address to bind to
      address = "0.0.0.0"
      address = ${?https.address}

      # The SSL engine provider
      engineProvider = "play.core.server.ssl.DefaultSSLEngineProvider"
      engineProvider = ${?play.http.sslengineprovider}

      # HTTPS keystore configuration, used by the default SSL engine provider
      keyStore {
        # The path to the keystore
        path = ${?https.keyStore}

        # The type of the keystore
        type = "JKS"
        type = ${?https.keyStoreType}

        # The password for the keystore
        password = "mansour"
        password = ${?https.keyStorePassword}

        # The algorithm to use. If not set, uses the platform default algorithm.
        algorithm = ${?https.keyStoreAlgorithm}
      }

      # HTTPS truststore configuration
      trustStore {

        # If true, does not do CA verification on client side certificates
        noCaVerification = false
      }
    }

    # The type of ServerProvider that should be used to create the server.
    # If not provided, the ServerStart class that instantiates the server
    # will provide a default value.
    provider = ${?server.provider}

    # The path to the process id file created by the server when it runs.
    # If set to "/dev/null" then no pid file will be created.
    pidfile.path = ${play.server.dir}/RUNNING_PID
    pidfile.path = ${?pidfile.path}



    # Configuration options specific to Netty
    netty {
      # The maximum length of the initial line. This effectively restricts the maximum length of a URL that the server will
      # accept, the initial line consists of the method (3-7 characters), the URL, and the HTTP version (8 characters),
      # including typical whitespace, the maximum URL length will be this number - 18.
      maxInitialLineLength = 4096
      maxInitialLineLength = ${?http.netty.maxInitialLineLength}

      # The maximum length of the HTTP headers. The most common effect of this is a restriction in cookie length, including
      # number of cookies and size of cookie values.
      maxHeaderSize = 8192
      maxHeaderSize = ${?http.netty.maxHeaderSize}

      # The maximum length of body bytes that Netty will read into memory at a time.
      # This is used in many ways.  Note that this setting has no relation to HTTP chunked transfer encoding - Netty will
      # read "chunks", that is, byte buffers worth of content at a time and pass it to Play, regardless of whether the body
      # is using HTTP chunked transfer encoding.  A single HTTP chunk could span multiple Netty chunks if it exceeds this.
      # A body that is not HTTP chunked will span multiple Netty chunks if it exceeds this or if no content length is
      # specified. This only controls the maximum length of the Netty chunk byte buffers.
      maxChunkSize = 8192
      maxChunkSize = ${?http.netty.maxChunkSize}

      # Whether the Netty wire should be logged
      log.wire = false
      log.wire = ${?http.netty.log.wire}

      # Netty options. Possible keys here are defined by:
      #
      # http://netty.io/3.9/api/org/jboss/netty/channel/socket/SocketChannelConfig.html
      # http://netty.io/3.9/api/org/jboss/netty/channel/socket/ServerSocketChannelConfig.html
      # http://netty.io/3.9/api/org/jboss/netty/channel/socket/nio/NioSocketChannelConfig.html
      #
      # Options that pertain to the listening server socket are defined at the top level, options for the sockets associated
      # with received client connections are prefixed with child.*
      option {

        # Set whether connections should use TCP keep alive
        # child.keepAlive = false

        # Set whether the TCP no delay flag is set
        # child.tcpNoDelay = false

        # Set the size of the backlog of TCP connections.  The default and exact meaning of this parameter is JDK specific.
        # backlog = 100
      }
    }
  }

  # Configuration specific to Play's experimental Akka HTTP backend
  akka {
    # How long to wait when binding to the listening socket
    http-bind-timeout = 5 seconds
  }
}